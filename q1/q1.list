				;file G:\ALTIUM\q1\q1\q1.c
				;1	#include "HT66F004.h"
				;2	
				;3	static volatile unsigned int adc_val;
				;4	static volatile unsigned char last_zc;
				;5	static volatile unsigned int trig;
				;6	static volatile unsigned int lastper;
				;7	static volatile unsigned char adc_ch1 = 0x01;
				@ROMDATA_BASE .SECTION 'CODE'
000D	0901	ret     a, 1H
000E	0000	nop
000F	0000	nop
				;8	static volatile unsigned char cntr;
				;9	static volatile unsigned int i = 0x0000;  //a 16 bits integer in order to shift adc register
				;10	
				;11	void main()
				;12	{
				@code .SECTION 'CODE'
				include HT66F004.inc
0000	281C	jmp     _main_startup
0001	0000	nop
0002	0000	nop
0003	0000	nop
0004	0000	nop
0005	0000	nop
0006	0000	nop
0007	0000	nop
				startupend3:
				@start .SECTION 'CODE'
0040	2841	jmp     _main
				;13	    //WDT_init()
				;14		_ws2=0;
				_main:
				_main:
0041	3519	clr     WS2
				;15		_ws1=1;
0042	3099	set     WS1
				;16		_ws0=1;
0043	3019	set     WS0
				;17		
				;18	    //WDT_ENABLE();
				;19		_we4=0;
0044	3799	clr     WE4
				;20		_we3=1;
0045	3319	set     WE3
				;21		_we2=0;
0046	3699	clr     WE2
				;22		_we1=1;
0047	3219	set     WE1
				;23		_we0=0;
0048	3599	clr     WE0
				;24		
				;25	    _hlclk = 1; //set system clock at FH
0049	300B	set     HLCLK
				;26	
				;27	    //input for ZC
				;28	    _pbc0 = 1;
004A	303B	set     PBC0
				;29	
				;30	    //output for driving the gate
				;31	    _pcc0 = 0;
004B	343E	clr     PCC0
				;32	    _pc0 = 0;
004C	343D	clr     PC0
				;33	
				;34	    //two outputs for two LEDs
				;35	    _pcc1 = 0;  //LED1
004D	34BE	clr     PCC1
				;36	    _pc1 = 0;
004E	34BD	clr     PC1
				;37	
				;38	    _pcc2 = 0;  //LED2
004F	353E	clr     PCC2
				;39	    _pc2 = 0;
0050	353D	clr     PC2
				;40	
				;41	    last_zc = _pb1;
0051	1F47	clr     last_zc[0]
0052	3CBA	sz      PB1
0053	14C7	inc     last_zc[0]
				;42	
				;43	    trig = 625;  //5ms time for driving triac
0054	0F71	mov     a, 71H
0055	00C5	mov     trig[0], a
0056	0F02	mov     a, 2H
0057	00C6	mov     trig[1], a
				;44		lastper = 626;  
0058	0F72	mov     a, 72H
0059	00C3	mov     lastper[0], a
005A	0F02	mov     a, 2H
005B	00C4	mov     lastper[1], a
				;45		adc_val = 0;
005C	1F48	clr     adc_val[0]
005D	1F49	clr     adc_val[1]
				;46		cntr = 8;
005E	0F08	mov     a, 8H
005F	00C2	mov     cntr[0], a
				;47	
				;48		//TimeBase_Init();
				;49		_tbck = 1;   //TB_CLOCK_FSYS_DIV4
0060	331B	set     TBCK
				;50	
				;51		//TB0_Period_2_8
				;52		_tb02=1;  
0061	311B	set     TB02
				;53		_tb01=1; 
0062	309B	set     TB01
				;54		_tb00=1;
0063	301B	set     TB00
				;55	
				;56		//STM_Init()
				;57		//STM_TIMER_COUNTER_MODE
				;58	    _pt0m1 = 1;  
0064	33AA	set     PT0M1
				;59		_pt0m0 = 1;
0065	332A	set     PT0M0
				;60	
				;61		//STM_FH_DIV64
				;62		_pt0ck2 = 0;  
0066	3729	clr     PT0CK2
				;63		_pt0ck1 = 1; 
0067	32A9	set     PT0CK1
				;64		_pt0ck0 = 1;
0068	3229	set     PT0CK0
				;65	
				;66		 _pt0cclr = 1;  //STM_CCRA_MATCH
0069	302A	set     PT0CCLR
				;67	
				;68	    //enable TimeBase0 interrupt
				;69		_tb0e = 1;
006A	310E	set     TB0E
				;70		
				;71		_mf0f = 0;	//clear multi-function 0 interrupt flag
006B	360F	clr     MF0F
				;72		_mf0e = 1;  //enable multifunction interrupt
006C	300F	set     MF0E
				;73	
				;74		_ptma0f = 0;	//clear STM CCRA interrupt flag
006D	3691	clr     PTMA0F
				;75		_ptma0e = 1;	//enable STM CCRA interrupt
006E	3091	set     PTMA0E
				;76		
				;77		_emi = 1;  //enable global interrupt
006F	300E	set     EMI
				;78	
				;79		_tbon = 1;  //enable TimeBase 
0070	339B	set     TBON
				;80	
				;81		//ADC_Init();	
				;82		//ADC_CLOCK_FSYS_DIV8
				;83		_sacks2 = 0;
0071	3523	clr     SACKS2
				;84		_sacks1 = 1;  
0072	30A3	set     SACKS1
				;85		_sacks0 = 1;     
0073	3023	set     SACKS0
				;86		           	
				;87	    //ADC_REF_VOLTAGE_VDD
				;88		_savrs3 = 0;
0074	35A4	clr     SAVRS3
				;89		_savrs2 = 0;  
0075	3524	clr     SAVRS2
				;90		_savrs1 = 0; 
0076	34A4	clr     SAVRS1
				;91		_savrs0 = 0;  
0077	3424	clr     SAVRS0
				;92	
				;93	    //ADC_VALUE_ALIGN_RIGHT
				;94		_adrfs = 1;                                          
0078	3222	set     ADRFS
				;95	
				;96		//clear ADC chanel
				;97		_sadc0 &= 0b11111000;
0079	0FF8	mov     a, F8H
007A	06A2	andm    a, SADC0
				;98	
				;99		//selection external ADC chanel
				;100		_sadc0 |= adc_ch1;
007B	074A	mov     a, adc_ch1[0]
007C	05A2	orm     a, SADC0
				;101	
				;102		_pbs1 = 1; //AN1
007D	30A7	set     PBS1
				;103	
				;104		_enadc = 1;  //enable ADC
007E	32A2	set     ENADC
				;105		
				;106		//enable ADC interrupt
				;107		_adf = 0;
007F	370F	clr     ADF
				;108		_ade = 1;
0080	310F	set     ADE
				;109		
				;110	    //start ADC
				;111		_start = 0;  
0081	37A2	clr     START
				;112		_start = 1;
0082	33A2	set     START
				;113		_start = 0;
0083	37A2	clr     START
				;114	    while(1)
				;115	    {
				;116	        if(!cntr)
				_L7:
0084	10C2	sz      cntr[0]
0085	28B0	jmp     _L2
				;117			{
				;118				if(adc_val<1024)
0086	0FFF	mov     a, FFH
0087	0248	sub     a, adc_val[0]
0088	0F03	mov     a, 3H
0089	1249	sbc     a, adc_val[1]
008A	380A	snz     C
008B	2892	jmp     _L3
				;119	            {
				;120	               lastper = 939;   //fire angle on 7.5ms
008C	0FAB	mov     a, ABH
008D	00C3	mov     lastper[0], a
008E	0F03	mov     a, 3H
008F	00C4	mov     lastper[1], a
				;121	               _pa3 = 0;
0090	3594	clr     PA3
0091	289D	jmp     _L8
				;122	               _pa4 = 0;
				;123	            }
				;124	            else if(adc_val<2048)
				_L3:
0092	0FFF	mov     a, FFH
0093	0248	sub     a, adc_val[0]
0094	0F07	mov     a, 7H
0095	1249	sbc     a, adc_val[1]
0096	380A	snz     C
0097	289F	jmp     _L4
				;125	            {
				;126	                lastper =689;   //fire angle on 5.5ms
0098	0FB1	mov     a, B1H
0099	00C3	mov     lastper[0], a
009A	0F02	mov     a, 2H
009B	00C4	mov     lastper[1], a
				;127	                _pa3 = 1;
009C	3194	set     PA3
				;128	                _pa4 = 0;
				_L8:
009D	3614	clr     PA4
009E	28B0	jmp     _L2
				;129	            }
				;130	            else if(adc_val<3072)
				_L4:
009F	0FFF	mov     a, FFH
00A0	0248	sub     a, adc_val[0]
00A1	0F0B	mov     a, BH
00A2	1249	sbc     a, adc_val[1]
00A3	380A	snz     C
00A4	28AB	jmp     _L5
				;131	            {
				;132	                lastper = 439;   //fire angle on 3.5ms
00A5	0FB7	mov     a, B7H
00A6	00C3	mov     lastper[0], a
00A7	0F01	mov     a, 1H
00A8	00C4	mov     lastper[1], a
				;133	                _pa3 = 0;
00A9	3594	clr     PA3
00AA	28AF	jmp     _L9
				;134	                _pa4 = 1;
				;135	            }
				;136	            else
				;137	            {  
				;138	               lastper = 189;  ////fire angle on 1.5ms
				_L5:
00AB	0FBD	mov     a, BDH
00AC	00C3	mov     lastper[0], a
00AD	1F44	clr     lastper[1]
				;139	               _pa3 = 1;
00AE	3194	set     PA3
				;140	               _pa4 = 1;
				_L9:
00AF	3214	set     PA4
				;141	            }
				;142			}
				;143	        
				;144	        if(_adbz == 0)
				_L2:
00B0	3F22	sz      ADBZ
00B1	28B5	jmp     _L6
				;145			{
				;146			  //start ADC
				;147			  _start = 0;  
00B2	37A2	clr     START
				;148		      _start = 1;
00B3	33A2	set     START
				;149		      _start = 0;
00B4	37A2	clr     START
				;150			}
				;151	
				;152			_wrf = 0; //refreshing WDT
				_L6:
00B5	341C	clr     WRF
				;153	    }
00B6	2884	jmp     _L7
00B7	28B7	jmp     $
				;154	}
				;155	
				;156	/* 128us Time Interval For Detecting ZC and Driving Triac. */
				;157	void __attribute((interrupt(0x08))) TB0_ISR(void)
				;158	{
				@TB0_ISR_code .SECTION 'CODE'
0008	00CC	mov     r108, a
0009	070A	mov     a, STATUS
000A	00CD	mov     r208, a
000B	28B8	jmp     _TB0_ISR
				;159	
				;160		if(_pb1 ^ last_zc)
				_TB0_ISR:
				_TB0_ISR:
				@dummy .SECTION 'CODE'
00B8	1F4E	clr     rd08
00B9	3CBA	sz      PB1
00BA	14CE	inc     rd08
00BB	1F4F	clr     re08
00BC	0747	mov     a, last_zc[0]
00BD	00D0	mov     rb08, a
00BE	1F51	clr     rc08
00BF	074E	mov     a, rd08
00C0	0450	xor     a, rb08
00C1	074F	mov     a, re08
00C2	3D0A	sz      Z
00C3	0451	xor     a, rc08
00C4	3D0A	sz      Z
00C5	28EA	jmp     _L11
				;161		{
				;162			_tb0f = 0;  //clear TB0 flag
00C6	368E	clr     TB0F
				;163			last_zc = _pb1;	
00C7	1F47	clr     last_zc[0]
00C8	3CBA	sz      PB1
00C9	14C7	inc     last_zc[0]
				;164			if((trig > lastper) && _pb1)
00CA	0743	mov     a, lastper[0]
00CB	0245	sub     a, trig[0]
00CC	0744	mov     a, lastper[1]
00CD	1246	sbc     a, trig[1]
00CE	3C0A	sz      C
00CF	28D7	jmp     _L13
00D0	38BA	snz     PB1
00D1	28D7	jmp     _L13
				;165				trig -= 10;  //Trig_Var.Step;	
00D2	0FF6	mov     a, F6H
00D3	03C5	addm    a, trig[0]
00D4	0FFF	mov     a, FFH
00D5	13C6	adcm    a, trig[1]
00D6	28DD	jmp     _L14
				;166							
				;167			else if(_pb1)
				_L13:
00D7	38BA	snz     PB1
00D8	28DD	jmp     _L14
				;168				trig += 10;  //Trig_Var.Step;	
00D9	0F0A	mov     a, AH
00DA	03C5	addm    a, trig[0]
00DB	0F00	mov     a, 0H
00DC	13C6	adcm    a, trig[1]
				;169	
				;170			_ptm0al = trig & 0x00ff;
				_L14:
00DD	0745	mov     a, trig[0]
00DE	00D0	mov     rb08, a
00DF	0746	mov     a, trig[1]
00E0	00D1	mov     rc08, a
00E1	0750	mov     a, rb08
00E2	00AD	mov     PTM0AL, a
				;171			_ptm0ah = trig >> 8;
00E3	0745	mov     a, trig[0]
00E4	00D0	mov     rb08, a
00E5	0746	mov     a, trig[1]
00E6	00D1	mov     rc08, a
00E7	0751	mov     a, rc08
00E8	00AE	mov     PTM0AH, a
				;172		
				;173			_pt0on = 1;  //enable STM
00E9	31A9	set     PT0ON
				_L11:
00EA	074D	mov     a, r208
00EB	008A	mov     STATUS, a
00EC	074C	mov     a, r108
00ED	0004	reti
				;174		}		
				;175	}
				;176	
				;177	void __attribute((interrupt(0x10))) Timer_ISR(void)
				;178	{				
				@Timer_ISR_code .SECTION 'CODE'
0010	00D2	mov     r110, a
0011	070A	mov     a, STATUS
0012	00D3	mov     r210, a
0013	28EE	jmp     _Timer_ISR
				@dummy16 .SECTION 'CODE'
0014	0000	nop
0015	0000	nop
0016	0000	nop
0017	0000	nop
				;179		if(!_pc0)
				_Timer_ISR:
				_Timer_ISR:
00EE	3C3D	sz      PC0
00EF	28F8	jmp     _L22
				;180		{
				;181			_pc0 = 1;
00F0	303D	set     PC0
				;182			_ptma0f = 0;  //clear timer flag
00F1	3691	clr     PTMA0F
				;183			_pt0on  = 0;  //disable the timer
00F2	35A9	clr     PT0ON
				;184	
				;185			//make a narrow pulse
				;186			_ptm0al = 4;
00F3	0F04	mov     a, 4H
00F4	00AD	mov     PTM0AL, a
				;187			_ptm0ah = 0;
00F5	1F2E	clr     PTM0AH
				;188	
				;189			_pt0on  = 1;  //enable the timer
00F6	31A9	set     PT0ON
00F7	28FB	jmp     _L21
				;190		}
				;191		else
				;192		{
				;193			_pc0 = 0;
				_L22:
00F8	343D	clr     PC0
				;194			_ptma0f = 0; 
00F9	3691	clr     PTMA0F
				;195			_pt0on  = 0;
00FA	35A9	clr     PT0ON
				_L21:
00FB	0753	mov     a, r210
00FC	008A	mov     STATUS, a
00FD	0752	mov     a, r110
00FE	0004	reti
				;196		}
				;197	}
				;198	
				;199	
				;200	
				;201	void __attribute((interrupt(0x18))) ADC_ISR(void)
				;202	{
				@ADC_ISR_code .SECTION 'CODE'
0018	00D4	mov     r118, a
0019	070A	mov     a, STATUS
001A	00D5	mov     r218, a
001B	28FF	jmp     _ADC_ISR
				;203		_adf = 0;	//clear adc flag
				_ADC_ISR:
				_ADC_ISR:
00FF	370F	clr     ADF
				;204		
				;205		if(cntr)
0100	10C2	sz      cntr[0]
0101	2903	jmp     _LI1
0102	2913	jmp     _L25
				;206		{
				;207			adc_val = (adc_val) + (((i | _sadoh)<<8) | _sadol);
				_LI1:
0103	0741	mov     a, i[1]
0104	00D6	mov     rc18, a
0105	0721	mov     a, SADOH
0106	0540	or      a, i[0]
0107	00D7	mov     rb18, a
0108	0757	mov     a, rb18
0109	00D6	mov     rc18, a
010A	1F57	clr     rb18
010B	0720	mov     a, SADOL
010C	05D7	orm     a, rb18
010D	0757	mov     a, rb18
010E	03C8	addm    a, adc_val[0]
010F	0756	mov     a, rc18
0110	13C9	adcm    a, adc_val[1]
				;208			cntr--;
0111	15C2	dec     cntr[0]
0112	291B	jmp     _L24
				;209		}
				;210		else
				;211		{
				;212			cntr = 8;
				_L25:
0113	0F08	mov     a, 8H
0114	00C2	mov     cntr[0], a
				;213			adc_val = adc_val >> 3;
0115	0F03	mov     a, 3H
				_LI2:
0116	340A	clr     C
0117	1BC9	rrc     adc_val[1]
0118	1BC8	rrc     adc_val[0]
0119	1785	sdz     ACC
011A	2916	jmp     _LI2
				_L24:
011B	0755	mov     a, r218
011C	008A	mov     STATUS, a
011D	0754	mov     a, r118
011E	0004	reti
				;214		}
				;215		    
				;216	}
				;file G:\ALTIUM\q1\q1\startup1.asm
				;1	;;--------------------------------------------------------------;;
				;2	;;    This file is part of the Holtek C Compiler V3 package     ;;
				;3	;;    For the initialization of static linkage variables        ;;
				;4	;;    Copyright (C) 2017 Holtek Semiconductor Inc.              ;;
				;5	;;    Version: 1.07 (Above IDE3000 V7.94)                       ;;
				;6	;;    Date:    2017/03/06                                        ;;
				;7	;;--------------------------------------------------------------;;
				;8	
				;9	acc equ [05h]
				;10	mp equ [01h]
				;11	iar equ [00h]
				;12	bp equ [04h]
				;13	z equ [0ah].2
				;14	c equ [0ah].0
				;15	public _main_startup
				;16	@start   .SECTION 'CODE'
				;17	_main_startup:
				;18	 ;;	CLR WDT2    ;;PD,TO flag will be clear. This line can be removed if a small number of global variables in C program are used.
				;19		Mov a, offset __initial_value_end
				_main_startup:
				@start .SECTION 'CODE'
				@dummy24 .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
001C	0F4B	mov     a, 4BH
				;20		dec acc
001D	1585	dec     ACC
				;21		MOV mp,A
001E	0081	mov     MP0, a
				;22		clr c
001F	340A	clr     C
				;23		Sub a, offset __initial_value_begin
0020	0A4A	sub     a, 4AH
				;24		snz c
0021	380A	snz     C
				;25		jmp startupend1
0022	282A	jmp     startupend1
				;26	L0004:
				;27		mov ra,a
				L0004:
0023	00CB	mov     ra, a
				;28		CALL romdata_base1
0024	200C	call    romdata_base1
				;29		MOV iar,A
0025	0080	mov     [00H], a
				;30		dec mp
0026	1581	dec     MP0
				;31	  ;;	CLR WDT   ;;PD,TO flag will be clear. This line can be removed if a small number of global variables in C program are used.
				;32		deca ra
0027	154B	deca    ra
				;33		sz ra
0028	10CB	sz      ra
				;34		jmp L0004 
0029	2823	jmp     L0004
				;35	startupend1:
				;36	ifndef Disable_Bit_Initial
				;37		MOV A,offset bitdatasec1_end
				startupend1:
002A	0F4B	mov     a, 4BH
				;38		mov mp,A
002B	0081	mov     MP0, a
				;39		dec mp
002C	1581	dec     MP0
				;40		clr z
002D	350A	clr     Z
				;41		sub a,offset bitdatasec1_start
002E	0A4B	sub     a, 4BH
				;42		sz z
002F	3D0A	sz      Z
				;43		jmp startupend2
0030	2835	jmp     startupend2
				;44	L0005:
				;45		set iar
				L0005:
0031	1F80	set     [00H]
				;46		dec mp
0032	1581	dec     MP0
				;47		sdz  acc
0033	1785	sdz     ACC
				;48		jmp L0005
0034	2831	jmp     L0005
				;49	
				;50	startupend2:
				;51		MOV A,offset bitdatasec0_end
				startupend2:
0035	0F4B	mov     a, 4BH
				;52		mov mp,A
0036	0081	mov     MP0, a
				;53		dec mp
0037	1581	dec     MP0
				;54		clr z
0038	350A	clr     Z
				;55		sub a,offset bitdatasec0_start
0039	0A4B	sub     a, 4BH
				;56		sz z
003A	3D0A	sz      Z
				;57		jmp startupend3
003B	2840	jmp     startupend3
				;58	L0006:
				;59		clr iar
				L0006:
003C	1F00	clr     [00H]
				;60		dec mp
003D	1581	dec     MP0
				;61		sdz  acc
003E	1785	sdz     ACC
				;62		jmp L0006
003F	283C	jmp     L0006
				;63			
				;64	startupend3:
				;65	endif
				;66	ROMBANK 0 @ROMDATA_BASE 
				;67	@ROMDATA_BASE .SECTION  inpage com_l 'CODE'
				;68	romdata_base1:
				;69		ADDM A,[06H]
				romdata_base1:
				@ROMDATA_BASE .SECTION 'CODE'
				@dummy8 .SECTION 'CODE'
000C	0386	addm    a, PCL
				;70	
				;71	@HCCINIT   .SECTION  COM_L 'DATA'
				;72	__initial_value_begin:
				;73	@HCCINIT  .SECTION COM_E 'DATA'
				;74	__initial_value_end:
				;75	
				;76	
				;77	@BITDATASEC1 .SECTION com_l 'DATA'  
				;78	bitdatasec1_start:
				;79	
				;80	@BITDATASEC1 .SECTION com_e 'DATA'  
				;81	bitdatasec1_end:
				;82	
				;83	@BITDATASEC .SECTION com_l 'DATA'  
				;84	startup_value:
				;85	bitdatasec0_start:
				;86	
				;87	@BITDATASEC .SECTION com_e 'DATA'  
				;88	bitdatasec0_end:
				;89	
				;90	extern ra:byte
				data .SECTION 'DATA'
				__smod DB DUP (?) ; __smod
				__intc0 DB DUP (?) ; __intc0
				__intc1 DB DUP (?) ; __intc1
				__mfi0 DB DUP (?) ; __mfi0
				__pa DB DUP (?) ; __pa
				__wdtc DB DUP (?) ; __wdtc
				__tbc DB DUP (?) ; __tbc
				__smod1 DB DUP (?) ; __smod1
				__sadol DB DUP (?) ; __sadol
				__sadoh DB DUP (?) ; __sadoh
				__sadc0 DB DUP (?) ; __sadc0
				__sadc1 DB DUP (?) ; __sadc1
				__sadc2 DB DUP (?) ; __sadc2
				__pbsr DB DUP (?) ; __pbsr
				__ptm0c0 DB DUP (?) ; __ptm0c0
				__ptm0c1 DB DUP (?) ; __ptm0c1
				__ptm0al DB DUP (?) ; __ptm0al
				__ptm0ah DB DUP (?) ; __ptm0ah
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pc DB DUP (?) ; __pc
				__pcc DB DUP (?) ; __pcc
				i DB 2 DUP (?) ; i
				cntr DB DUP (?) ; cntr
				lastper DB 2 DUP (?) ; lastper
				trig DB 2 DUP (?) ; trig
				last_zc DB DUP (?) ; last_zc
				adc_val DB 2 DUP (?) ; adc_val
				adc_ch1 DB DUP (?) ; adc_ch1
				ra DB DUP (?)
				r108 DB DUP (?)
				r208 DB DUP (?)
				rd08 DB DUP (?)
				re08 DB DUP (?)
				rb08 DB DUP (?)
				rc08 DB DUP (?)
				r110 DB DUP (?)
				r210 DB DUP (?)
				r118 DB DUP (?)
				r218 DB DUP (?)
				rc18 DB DUP (?)
				rb18 DB DUP (?)
